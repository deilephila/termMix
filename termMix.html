<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
    :root {
  --main_background-color: #232323;
  --main_text-color: #bbb;
  --text_inside: black;
}

html {
    background-color: var(--main_background-color);
    color: var(--main_text-color);
}
body {
    width: 50em;
    margin: auto;
    padding: 1em 5em;
    border-left: 1px solid #bbb;
    border-right: 1px solid #bbb;
}

div {
    margin: 0.5em;
    font-size: 1.2em;
}

input {
    display: block;
}

.mode {
    display: flex;
    padding: 1rem 0;
    gap: 1rem;
}


#mainHeader {
    font-size: 1.5rem;
}

#all {
    display: flex;
    flex-direction: row;
    align-items: baseline;
    justify-content: center;
    display: flex;
    gap: 1rem;
}

input[type="checkbox"], input[type="radio"] {
    all: unset;
    background: var(--main_background-color);
    width: 1em;
    height: 1em;
    border: 1px solid var(--main_text-color);
    border-radius: .5rem;
    transition: all 300ms;
}
input:checked {
    background: var(--main_text-color);
    border-radius: 50%;
}

#withBut {
display: flex;
align-items: center;
justify-content: center;
}

but {
width: 7em;
display: block;
display: flex;
align-items: center;
justify-content: center;
padding: 0.4em;
margin: 0.5em;
border: 4px solid black;
border-radius: 1rem;
background: white;
font-weight: bold;
text-align: center;
color: var(--text_inside);
}

#out {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

#warning {
    text-align: center;
    font-size: 1.7rem;
}

#selectShow {
    margin-bottom: 2rem;
}

#selectedShow {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    margin-bottom: 2rem;
}

</style>


<body>
<template id="blockTermToSelect">
    <div class = "block"> 
        <p></p>
        <div class="terminators">
        </div>
        <div class="selectWholeBlock"> 
            <input type="checkbox" id="checkall" value="">
             Select All
        </div>
    </div>
    <style>
        p {
            font-size: 1.5rem;
            margin: 0;
        }
        .block {
            font-size: 1.2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            gap: 1rem;
        }

        .terminators {
            display: flex;
            flex-direction: column;
            align-items: baseline;
            border: 5px solid #444;
            padding: 0.75rem;
            gap: .75rem;
            font-size: 1.25rem;
            border-radius: 1rem;
        }

        input[type="checkbox"] {
            all: unset;
            background: #232323;
            width: 1em;
            height: 1em;
            border: 1px solid #bbb;
            border-radius: .5rem;
            transition: all 300ms;
            display: inline-block;
        }

        input:checked {
            background: #bbb;
            border-radius: 50%;
        }

    </style>
</template>

<template id="oneTermToSelectInsideBlock">
    <div class="oneCheckBox">
        <input type="checkbox"> 
        <span></span>
    </div> 

    <style>
        input[type="checkbox"] {
            all: unset;
            background: #232323;
            width: 1em;
            height: 1em;
            border: 1px solid #bbb;
            border-radius: .5rem;
            transition: all 300ms;
        }

        input:checked {
            background: #bbb;
            border-radius: 50%;
        }

        .oneCheckBox {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            gap: 0.5em;
            font-size: 1.25rem;
        }
    </style>
</template>

<template id="oneMixOut">
    <header></header>
    <table id="diffs"></table>
    <div class="flex-h">
        <table id="stats"></table>
        <div id="price">
            <p></p>
            <details>
                <summary></summary>
                <ul>
                    <li class="info" id="A">
                    <li class="info" id="T">
                    <li class="info" id="C">
                    <li class="info" id="G">
                </ul>
            </details>
        </div>
    </div>
    <hr />
    <style>
        :host {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1.5rem;
            transition: all 300ms;
            border-radius: 1.5rem;
            border: 2px solid var(--main_background-color);
        }
        :host(:hover) {
            border: 2px solid #444;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        table, td, th {
            border: 1px solid #444;
            font-weight: 400;
            background: var(--main_background-color);
        }

        #diffs th {
            width: 10em;
        }
        th:first-child {
            font-weight: 800;
        }
        th[color="conflict"] {
            background: #660000;
        }

        .bold {
            font-weight: 800;
        }

        #stats {
            width: 14rem;
            height: fit-content;
        }
        #stats th {
            text-align: start;
            padding: .25rem .75rem;
        }

        *:empty {
            display: none;
        }
        * {
            margin: 0;
        }
        #price {
            padding: .5rem 0;
        }
        .flex-h {
            display: flex;
            gap: 1rem;
        }

        .info {
            font-size: 1rem;
        }

        summary {
            margin-bottom: 0.8rem;
        }
    </style>
</template>

<template id="sortSelect">
    <div>
        <label for="sort">Sort</label>
        <select name="sort">
            <option name="sort" id="default" selected disabled> none </option>
            <option name="sort" value="general" id="generalSort"> by general rating </option>
            <option name="sort" value="price"> by price </option>
            <option name="sort" value="min"> by min </option>
            <option name="sort" value="max"> by max </option>
            <option name="sort" value="sum"> by sum </option>
            <option name="sort" value="geomMean"> by geom mean </option>
        </select>
    </div>

    <style>
        :host {
            display: flex;
            flex-direction: row-reverse;
        }
        
        #sort {
            font-size: 1.2rem;
            display: flex;
            flex-direction: row;
            justify-content: flex-end;
            margin: 0;
            gap: 1rem;
        }
        label {
            margin: 1rem;
        }
    </style>
</template>

<template id="Warning">
    <div><p id="warning"></p></div>
    <style>
        #warning {
            text-align: center;
            font-size: 1.7rem;
        }
    </style>
</template>

<template id="AddFilter">
    <div>
        <label for="show">Filter</label>
        <select name="show">
        </select>
    </div>

</template>

<template id="AddedFilter">
    <div>
        <p></p>
        <button>x</button>
    </div>

    <style>
        p {
            margin: 0;
        }

        div {
            display: flex;
            gap: 0.5rem;
            flex-direction: row;
            align-items: center;
        }

        input {
            all: unset;
            width: 1.5rem;
            height: 1.5rem;
            display: block;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
            background: white;
            font-weight: bold;
            color: var(--text_inside);
            }
    </style>
</template>

<template id="outputTemplate"></template>

    <header id="mainHeader">Termination Mix</header>
    <div class = "mode">
        <input name="r1" type="radio" value="" checked="checked"> Suitable only
        <input name="r1" type="radio" value=""> All variants
    </div> </div>
    <div id="all"></div>
    <div id='withBut'><but id="run">Run</but></div>
    <div id="selectShow"></div>
    <div id="selectedShow"></div>
    <div id="sort"></div>
    <div id="out"></div>

<script>

const letters = ["A", "T", "C", "G"];

//мапка со всей инфой о терминаторах
const allterms = {
        "ddATP": {
            type: "A",
            massSpectra: 296,
            price: 
                [{
                    rub: 7,
                    company: "Биолабмикс",
                    info: "оф.сайт"},
                {   rub: 17,
                    company: "ДНК-Синтез",
                    info: "оф.сайт"},
                {   rub: 20,
                    company: "ДиаМ",
                    info: "оф.сайт"}]},
        "ddTTP": {
            type: "T",
            massSpectra: 287,
            price: 
                [{
                    rub: 7,
                    company: "Биолабмикс",
                    info: "оф.сайт"},
                {   rub: 17,
                    company: "ДНК-Синтез",
                    info: "оф.сайт"},
                {   rub: 20,
                    company: "ДиаМ",
                    info: "оф.сайт"}]},
        "ddUTP": {
            type: "T",
            massSpectra: 274,
            price: 
                [{
                    rub: 7,
                    company: "Биолабмикс",
                    info: "оф.сайт"}]},
        "ddCTP": {
            type: "C",
            massSpectra: 272,
            price: 
                [{
                    rub: 7,
                    company: "Биолабмикс",
                    info: "оф.сайт",
                    priceForOne: true},
                {   rub: 17,
                    company: "ДНК-Синтез",
                    info: "оф.сайт"},
                {   rub: 20,
                    company: "ДиаМ",
                    info: "оф.сайт"}]},
        "ddGTP": {
            type: "G",
            massSpectra: 312,
            price: 
                [{
                    rub: 7,
                    company: "Биолабмикс",
                    info: "оф.сайт"},
                {   rub: 17,
                    company: "ДНК-Синтез",
                    info: "оф.сайт"},
                {   rub: 20,
                    company: "ДиаМ",
                    info: "оф.сайт"}]},

        "acyATP": {
            type: "A",
            massSpectra: 271,
            price: 
                [{
                    rub: 24,
                    company: "NEB (через Синген)",
                    info: "КП № УТ-8819 от 13.12.2023",
                    priceForOne: false}]},
        "acyTTP": {
            type: "T",
            massSpectra: 262,
            price: 
                [{
                    rub: 24,
                    company: "NEB (через Синген)",
                    info: "КП № УТ-8819 от 13.12.2023",
                    priceForOne: false}]},
        "acyCTP": {
            type: "C",
            massSpectra: 247,
            price: 
                [{
                    rub: 24,
                    company: "NEB (через Синген)",
                    info: "КП № УТ-8819 от 13.12.2023",
                    priceForOne: false}]},
        "acyGTP": {
            type: "G",
            massSpectra: 287,
            price: 
                [{
                    rub: 24,
                    company: "NEB (через Синген)",
                    info: "КП № УТ-8819 от 13.12.2023",
                    priceForOne: false}]},

        "propargyl-amino-ddATP": {
            type: "A",
            massSpectra: 348,
            price: 
                [{
                    rub: 109,
                    company: "Jena Bioscience (через SPUTNIK)",
                    info: "оф. сайт sputnik-group",}]},

        "propargyl-amino-ddUTP": {
            type: "T",
            massSpectra: 326,
            price: 
                [{
                    rub: 32,
                    company: "Lumiprobe",
                    info: "КП #D9366 от 20.12.2023"},
                {
                    rub: 100,
                    company: "Jena Bioscience (через SPUTNIK)",
                    info: "оф. сайт sputnik-group"}]},

        "propargyl-amino-ddCTP": {
            type: "C",
            massSpectra: 325,
            price: 
                [{
                    rub: 99,
                    company: "Jena Bioscience (через SPUTNIK)",
                    info: "оф. сайт sputnik-group"}]},
                    
        "propargyl-amino-ddGTP": {
            type: "G",
            massSpectra: 264,
            price: 
                [{
                    rub: 186,
                    company: "Jena Bioscience (через SPUTNIK)",
                    info: "оф. сайт sputnik-group"}]},

        "AA-ddUTP": {
            type: "T",
            massSpectra: 328,
            price: 
                [{
                    rub: 36,
                    company: "Lumiprobe",
                    info: "КП #D9366 от 20.12.2023"}]},

        "amino-11-ddUTP": {
            type: "T",
            massSpectra: 441,
            price: 
                [{
                    rub: 45,
                    company: "Lumiprobe",
                    info: "оф. сайт"}]},

        "morATP": {
            type: "A",
            massSpectra: 311,
            price: 
                [{
                    rub: 2,
                    company: "Биолабмикс",
                    info: "оф. сайт"},
                {
                    rub: 6,
                    company: "ДиаМ",
                    info: "оф. сайт"}]},
        "morUTP": {
            type: "T",
            massSpectra: 302,
            price: 
                [{
                    rub: 2,
                    company: "Биолабмикс",
                    info: "оф. сайт"},
                {
                    rub: 5,
                    company: "ДиаМ",
                    info: "оф. сайт"}]},
        "morCTP": {
            type: "C",
            massSpectra: 287,
            price: 
                [{
                    rub: 2,
                    company: "Биолабмикс",
                    info: "оф. сайт"},
                {
                    rub: 5,
                    company: "ДиаМ",
                    info: "оф. сайт"}]},
        "morGTP": {
            type: "G",
            massSpectra: 327,
            price: 
                [{
                    rub: 2,
                    company: "Биолабмикс",
                    info: "оф. сайт"},
                {
                    rub: 6,
                    company: "ДиаМ",
                    info: "оф. сайт"}]},

        "d4TTP": {
            type: "T",
            massSpectra: 290}
    }


//все виды сортировки
const sortMethods = {
            general: (a,b) => a.generalSort.score - b.generalSort.score,
            price: (a,b) => a.sumPrice - b.sumPrice,
            min: (a,b) => a.stats.min - b.stats.min,
            max: (a,b) => a.stats.max - b.stats.max,
            sum: (a,b) => a.stats.sum - b.stats.sum,
            geomMean: (a,b) => a.stats["geom mean"] - b.stats["geom mean"]
        }

//параметры general сортировки 
const GeneralSortParametres = [28, 50, 70, 100, 440]; /// (интервалы цены 28-49, 50-69, 70-99, выше 99 рублей)

//глобальные переменные
let selectedSort; //выбранный режим сортировки
let allSelectedTerms = []; //все выбранные в чекбоксах буквы 

//HTML-элементы
const out = document.getElementById("out");
const selectShow = document.getElementById("selectShow"); 
const selectedShow = document.getElementById("selectedShow");
const divForSort = document.getElementById("sort");









//web-component for input oneTerm - input checkbox inside the block
customElements.define("one-term", class extends HTMLElement {
    
    shadowDOM = this.attachShadow({mode: "closed"});
    TermName = "";

    constructor() {
        super();

        const template = document
            .getElementById('oneTermToSelectInsideBlock')
            .content.cloneNode(true);
        
        this.shadowDOM.appendChild(template);
        this.checkbox = this.shadowDOM.querySelector("input");
    }

    set name(name) {
        this.TermName = name;
        this.shadowDOM.querySelector('span').innerText = this.TermName;
        
    }

    get state() {
        return this.checkbox.checked 
    }

    check() {
        this.checkbox.checked = true
    }

    uncheck() {
        this.checkbox.checked = false
    }

    toggle() {
        this.checkbox.checked = !this.checkbox.checked
    }

});

//web-component for input block of terminators
customElements.define("block-select", class extends HTMLElement {
    
    shadowDOM = this.attachShadow({mode: "closed"});
    name = "";
    termList = [];

    constructor() {
        super();
        const template = document.getElementById('blockTermToSelect').content.cloneNode(true);
        this.shadowDOM.appendChild(template);
        this.checkboxes = this.shadowDOM.querySelector('.terminators');
        this.checkboxAll = this.shadowDOM.getElementById("checkall");
    }

    set blockName(name) {
        this.name = name;
        const header = this.shadowDOM.querySelector('p');
        header.innerText = this.name;
    }

    addTerm(name) {
        const oneterm = document.createElement("one-term");
        oneterm.name = name;
        this.checkboxes.appendChild(oneterm);
        this.termList.push(oneterm);
    }

    connectedCallback() {
        this.checkboxAll.addEventListener("change",() => this.toggle())
    }

    get state() {
        return this.checkboxAll.checked 
    }

    select() {
        this.termList.forEach((oneterm) => {
            oneterm.check()
        })
    }

    unselect() {
        this.termList.forEach((oneterm) => {
            oneterm.uncheck()
        })
    }

    toggle() {
        this.state ? this.select() : this.unselect(); 
    }

    get selectedTerms() {
        const selected = [];
        this.termList.forEach((oneterm) => {
            oneterm.state && selected.push(oneterm.TermName)
        })
        return selected
    }

})

//web-component for one mix output
customElements.define("one-mix", class extends HTMLElement {
    
    shadowDOM = this.attachShadow({mode: "closed"});

    constructor() {
        super();

        const template = document.getElementById('oneMixOut').content.cloneNode(true);
        this.shadowDOM.appendChild(template);

        this.tableDiff = this.shadowDOM.getElementById("diffs");
        this.tableStats = this.shadowDOM.getElementById("stats");
        this.header = this.shadowDOM.querySelector('header');
        this.price = this.shadowDOM.querySelector('summary');
        this.details = [
            this.shadowDOM.getElementById('A'),
            this.shadowDOM.getElementById('T'),
            this.shadowDOM.getElementById('C'),
            this.shadowDOM.getElementById('G')
        ]
    }

    set addMix(onemix) {
        this.mix = onemix;
    }

    makePreTableDiff(pre) {
        const string1 = letters.map((letter) => {
            return `<th class="bold" >${pre[letter].name}</th>`
        });
        string1.unshift(`<th>type</th>`);

        const string2 = letters.map((letter) => {
            return `<th>${pre[letter].weight}</th>`
        });
        string2.unshift(`<th>weight, Da</th>`);

        const strings = letters.map((letterRow) => {
            const row = letters.map((letterCol) => {
                if (pre[letterRow].diffs[letterCol].status == "conflict") {
                    return `<th color="conflict">${pre[letterRow].diffs[letterCol].diffValue}</th>`
                } else {
                    return `<th>${pre[letterRow].diffs[letterCol].diffValue}</th>`
                }
            })
            row.unshift(`<th>${pre[letterRow].name}</th>`)
            return row
        });

        const all = [[string1, string2], strings].flat();
        const all2 = all.map(str => {
            return `${str.join("")}`});
        return all2
    }

    makePreTableStats(pre) {
        const prearray = Object.entries(pre.stats);
        const array = prearray.map(row => {
            return `<th>${row.join("</th><th>")}</th>`
        })
        return array
    }

    renderTable(pretable, htmlElement) {
        const tableHTML = 
        `<tr>
            ${
                pretable.join('</tr><tr>')
            }
        </tr>`
        htmlElement.innerHTML = tableHTML
    }

    makeDetails(mix) {
        let details = [];
        mix.prices.forEach (letter => {
            const inf = `${letter.terminator}: ${letter.price} руб/реак., ${letter.company}, ${letter.info}`;
            details.push(inf);        
        })
        return details
    }

    functionOUT() {
        const pretableDiff = this.makePreTableDiff(this.mix);
        const tableDiff = this.tableDiff;
        this.renderTable(pretableDiff, tableDiff);

        const pretableStats = this.makePreTableStats(this.mix);
        const tablestats = this.tableStats;
        this.renderTable(pretableStats, tablestats);

        this.price.innerText = `Price for 1 reaction: ${this.mix.sumPrice} rub`;

        const infoDetails = this.makeDetails(this.mix);

        for (let i=0; i<4; i++) {
            this.details[i].innerText = infoDetails[i]
        };
    }

});



//web-component for sort-select
customElements.define("sort-select", class extends HTMLElement {
    
    shadowDOM = this.attachShadow({mode: "closed"});

    constructor() {
        super();

        const template = document.getElementById('sortSelect').content.cloneNode(true);
        this.shadowDOM.appendChild(template);
        this.tagSelect = this.shadowDOM.querySelector('select');
        this.selectGeneralSort = this.shadowDOM.getElementById("generalSort");
        this.selectDefault = this.shadowDOM.getElementById("default");
       
    }

    //для ситуации, когда выбрана general sort, но произошло переключение на all mixes
    stateGeneralSelect(state) {
        if (state == true && this.selectGeneralSort.selected == true) {
            this.selectGeneralSort.selected = false;
            this.selectDefault.selected = true;
        }
        this.selectGeneralSort.disabled = state;
    }

    connectedCallback() {
        this.tagSelect.addEventListener("change", () => {
         //   selectedSort = this.tagSelect.value; //изменяем глобальную переменную - это можно будет убрать
            fullOut.setSortState = this.tagSelect.value; //закидываем sort state в WC output
        })
    }

    //функция сортировки, запускается из WC output
    makeSort (mixes) {
        const sortedMixToRender = mixes.sort(sortMethods[selectedSort]);
        return sortedMixToRender;
    }
})

//web-component for warning output
customElements.define("warning-output", class extends HTMLElement {
    
    shadowDOM = this.attachShadow({mode: "closed"});

    constructor() {
        super();

        const template = document.getElementById('Warning').content.cloneNode(true);
        this.shadowDOM.appendChild(template);

        this.html = this.shadowDOM.getElementById("warning");
        this.html.innerHTML = "There is no such termination mix  :("
    }

})


//эта глобальная переменная нужна для сортировки внутри селекта
const termSequence = ["ddATP", "ddTTP", "ddCTP", "ddGTP", "ddUTP",
"acyATP","acyTTP", "acyCTP", "acyGTP",
"propargyl-amino-ddATP",  "propargyl-amino-ddUTP", "propargyl-amino-ddCTP", 
"propargyl-amino-ddGTP", "AA-ddUTP", "amino-11-ddUTP", "morATP", "morUTP", "morCTP","morGTP"];

//web-component for add Filter
customElements.define("add-filter", class extends HTMLElement {
    
    shadowDOM = this.attachShadow({mode: "closed"});

    constructor() {
        super();

        const template = document.getElementById('AddFilter').content.cloneNode(true);
        this.shadowDOM.appendChild(template);

        this.selectHTML = this.shadowDOM.querySelector("select");
        this.option = new Object;
        this.toFilter = [];
    }

    set setAllMixes (mixes) {
        this.initialMixesToRender = mixes;
    }

    set deleteSelectedOption (name) {
        this.selectHTML.removeChild(this.option[name]);
    }

    clearSelect() {
        while (this.selectHTML.firstChild) {
            this.selectHTML.firstChild.remove();
        }
    }

    sortArrayOfOptionsNames (allOptionsNames) {
        const objects = allOptionsNames.map((actualOption) => ({
            index: termSequence.indexOf(actualOption),
            name: actualOption
        }));

        const sortedObj = objects.sort((a,b) => a.index - b.index);
        const sorted = sortedObj.map((obj) => obj.name);
        
        return sorted;
    }

    createFirstSelect() {
        const optionAll = document.createElement("option");
        optionAll.name = "show";
        optionAll.innerHTML = "All";
        optionAll.disabled = true;
        optionAll.selected = true;
        this.selectHTML.appendChild(optionAll);
    }

    //этот сэттер запускается из функции run, только после запуска рана
    set firstAddSelected (names) {
        this.allOptionsNames = names;
        this.addSelected = this.allOptionsNames // запускаем сэттер, который формирует ВК select со всеми options
    }

    //а этот сэттер может запускаться без рана, запускается изнутри, работает каждый раз когда мы добавляем или удаляем option
    set addSelected (names) {
        this.createFirstSelect() //создаем первый селект All
        this.optionsNames = this.sortArrayOfOptionsNames(names);// в этой переменной храним только те options, которые должны быть в селекте
        this.optionsNames.forEach (name => {
            const displayed = document.createElement("option");
            displayed.name = "show";
            displayed.value = name;
            displayed.innerHTML = name;
            this.selectHTML.appendChild(displayed);
            this.option[name] = displayed;
        })
    }

    set deleteSelected(wc) {
        selectedShow.removeChild(wc);
    }

    getFiltered() {
        if (this.toFilter.length > 0) {
                let MixesToRender = toShow (this.initialMixesToRender, this.toFilter);
                console.log("get Filtered", MixesToRender)
                fullOut.toRender(MixesToRender);
            } else {
               fullOut.toRender(this.initialMixesToRender);
            }
    }

    connectedCallback() {
        this.selectHTML.addEventListener("change", () => {
            this.toFilter.push(this.selectHTML.value);
            fullOut.setFilterState = this.toFilter;

            const webcompAdded = document.createElement("added-filter");
            webcompAdded.addTerm = this.selectHTML.value;

            this.optionsNames.splice(this.optionsNames.indexOf(this.selectHTML.value), 1); //обновляю optionsNames (убираю оттуда то, что пропало из options)
            this.clearSelect();
            this.addSelected = this.optionsNames;
            this.getFiltered();

            webcompAdded.addEventListener("remove", (e) => {
                this.deleteSelected = e.detail;
                this.optionsNames.push(e.detail.name);
                this.clearSelect();
                this.addSelected = this.optionsNames;
                toFilter.splice(toFilter.indexOf(e.detail.name), 1);
                fullOut.setFilterState = toFilter;
                this.getFiltered();
            }) 
            selectedShow.appendChild(webcompAdded);
        })
    }

})

//web-component for added Filter (and delete)
customElements.define("added-filter", class extends HTMLElement {
    
    shadowDOM = this.attachShadow({mode: "closed"});

    constructor() {
        super();

        const template = document.getElementById('AddedFilter').content.cloneNode(true);
        this.shadowDOM.appendChild(template);

        this.p = this.shadowDOM.querySelector("p");
        this.buttonDelete = this.shadowDOM.querySelector("button");
        this.div = this.shadowDOM.querySelector("div");
    }

    set addTerm (name) {
        this.name = name;
        this.p.innerText = name;
    }

    connectedCallback() {
        this.buttonDelete.addEventListener("click", () => {
            const event = new CustomEvent("remove", { detail: this });
            this.dispatchEvent(event);
        })
    }

})


//web-component for full output 
customElements.define("all-output", class extends HTMLElement {
    
    shadowDOM = this.attachShadow({mode: "closed"});

    constructor() {
        super();

        const template = document.getElementById('outputTemplate').content.cloneNode(true);
        this.shadowDOM.appendChild(template);

    }

    set setMixes (mixes) {
        this.allMixes = mixes;
    }

    //этот сэттер работает только при запуске рана, тут же задаем mode
    set setModeAndRender (modeState) {
        this.mode = modeState;
        this.MixesAfterMode = this.mode == "suitable" ? this.selectSuitable(this.allMixes) : this.allMixes;
        if (this.MixesAfterMode.length > 0) {
            this.toRender(this.MixesAfterMode);
            this.renderSort () //рендерим веб-компонент sort - он рендерится только при запуске рана
        } else {
            this.renderNoMix()
        };
    }

    selectSuitable(mixes) {
        const suitableMixes = [];
        mixes.forEach ((onemix) => {
            if (onemix.getStatus == "suitable") {
                onemix.priceCategory(GeneralSortParametres) //здесь параметры для категорий сортировки по цене!
                suitableMixes.push(onemix)
            }
        });
        return suitableMixes
    }

    set setFilterState (state) {
        this.filterState = state;
    }

    set setSortState (state) {
        this.sortState = state;
        this.MixesToRender = wcSort.makeSort(mixes);
        this.toRender(this.MixesToRender);
    }


    toRender (mixes) {
        clear(out); 
        console.log("toRender", mixes)
        mixes.forEach (oneMix => {
            const OneMixOut = document.createElement("one-mix");
            OneMixOut.addMix = oneMix;
            OneMixOut.functionOUT();
            this.shadowDOM.appendChild(OneMixOut);
        });
        console.log(mixes);

        this.renderFilter (); //рендерим веб-компонент filter
        

    }

    renderNoMix () {
        clear(out);
        clear(divForSort);
        const noMix = document.createElement("warning-output");
        this.shadowDOM.appendChild(noMix);
    }

    renderFilter () {
        clear(selectShow);
        const filterElement = document.createElement("add-filter");
        filterElement.firstAddSelected = allSelectedTerms;
        filterElement.setAllMixes = this.MixesAfterMode;
        selectShow.appendChild(filterElement);
    }


    //эта функция должна вызываться каждый раз при ране, т.к. нужно проводить проверку на general sort
    renderSort () {
        //этот ифэлс нужен для ситуации когда выбран general sort, но произошло переключение на all mixes
        if (this.mode != "suitable") {
            wcSort.stateGeneralSelect(true)
        } else {
            wcSort.stateGeneralSelect(false)
        }
        divForSort.appendChild(wcSort);
    }




})

//этот компонент для sort создается заранее 1 раз! не создается даже после запуска рана! 
const wcSort = document.createElement("sort-select");

//заранее созданный веб-компонент аутпута
const fullOut = document.createElement("all-output");

const allBlocks = [ 
    {   name: "Unmodified",
        terms: ["ddATP","ddTTP", "ddCTP", "ddGTP", "ddUTP"]},
    {   name: "Acyclic",
        terms: ["acyATP","acyTTP", "acyCTP", "acyGTP"]},
    {   name: "Amino",
        terms: ["propargyl-amino-ddATP",  "propargyl-amino-ddUTP", 
        "propargyl-amino-ddCTP", "propargyl-amino-ddGTP",
        "AA-ddUTP", "amino-11-ddUTP"]},
    {   name: "Morpholino",
        terms: ["morATP", "morUTP", "morCTP","morGTP"]}
]

//рендерим блоки терминаторов на странице
const allBlocksElements = allBlocks.map (oneblock => {
    const block = document.createElement("block-select");
    block.blockName = oneblock.name;
    oneblock.terms.forEach( t => block.addTerm(t) );
    document.getElementById("all").appendChild(block);
    return(block);
})

function makeTermList() {
    allSelectedTerms = allBlocksElements
        .map(oneblock => oneblock.selectedTerms).flat(); //записываем все выбранные терминаторы
 //   console.log(allSelectedTerms);
    const filtered = letters.reduce((accumulator,letter) => {
        accumulator[letter] = allSelectedTerms.filter(term => allterms[term].type == letter);
        return accumulator;
    }, new Object); //объединяем терминаторы по группам (А, Т, С, G)
 //   console.log(filtered);
    return filtered
}

//делаем комбинации букв для создания миксов
function makeAllMixes(terms) {
    let allMixes = [];
        for (let varNTP1=0; varNTP1<terms["A"].length; varNTP1++) {
            for (let varNTP2=0; varNTP2<terms["T"].length; varNTP2++) {
                for (let varNTP3=0; varNTP3<terms["C"].length; varNTP3++) {
                    for (let varNTP4=0; varNTP4<terms["G"].length; varNTP4++) {
                        const mix = {
                            A: terms["A"][varNTP1],
                            T: terms["T"][varNTP2],
                            C: terms["C"][varNTP3],
                            G: terms["G"][varNTP4],
                        };
                        allMixes.push(mix);
                    }
                }
            }
        }
    return allMixes
}

class Mix {
    constructor(onemix) {
        //тут создаем объекты из трех ключей
        letters.forEach (letter => {
            this[letter] = {
                name: onemix[letter],
                type: letter,
                weight: allterms[onemix[letter]].massSpectra
            }
        })
        // а тут добавляем в каждый объект (this.A/T/C/G) ключ diff, в его значении - obj
        //(формируется методом calculateDiffs)
        letters.forEach (letter => {
            this.calculateDiffs(this[letter]);
        });
        this.All = [this.A, this.T, this.C, this.G];
        
        this.makeConflictStatus(); // тут добавляем this.status = conflict / suitable
        this.makeStatistic();
        this.makePrice();
    }

    calculateDiffs(oneterm) {
        oneterm.diffs = new Object;
        letters.forEach (letter => {
            oneterm.diffs[letter] = {
                diffValue: oneterm.weight - allterms[this[letter].name].massSpectra,
                comparedType: letter,
                names: `${oneterm.name}-${this[letter].name}`,
            };
            oneterm.diffs[letter].status = 
            (Math.abs(oneterm.diffs[letter].diffValue) < 16 
            && oneterm.type != letter) ? "conflict" : "ok";
        })
        return oneterm;
    }

    //это я бы еще переписала, можно не получать массив из дифов, и вообще прерывать весь цикл
    //как только там появляется значение <16, потому что тогда мы сразу можем присваивать статус conflict
    makeConflictStatus() {
        const all = this.All;
        let alldiffs = [];
        for (let term=0; term<4; term++) {
            for (let i=0; i<4; i++) {
                    if (all[term].type != all[term].diffs[letters[i]].comparedType) {
                        alldiffs.push(all[term].diffs[letters[i]].diffValue);
                    }
                }
        }
        let conflicts = [];

        this.status = alldiffs.some(d => Math.abs(d) < 16) ? "conflict" : "suitable"
    }

    get getStatus () {
        return this.status
    }

    makeStatistic() {
        const all = this.All;
        const alldiffs = [];
        for (let term=0; term<4; term++) {
            for (let i=0; i<4; i++) {
                    if (all[term].type != all[term].diffs[letters[i]].comparedType) {
                        alldiffs.push(all[term].diffs[letters[i]].diffValue);
                    }
                }
        }

        //TODO!! переписать без forEach и if!
        const positiveDiffs = [];
        alldiffs.forEach(diff => {
            if (diff >= 0) {
                positiveDiffs.push(diff)
            }
        });
        const sorted = positiveDiffs.sort(function(a, b){return b-a});

        this.stats = {
            min: sorted[sorted.length-1],
            max: sorted[0],
            sum: sorted.reduce((accumulator, diff) => accumulator + diff),
            "geom mean": Number((sorted.reduce((accumulator, diff) => accumulator * diff))**(1/6)).toFixed(2)
        }
    }


    makePrice() {
        const terms = this.All.map((one) => {
            return one.name
        })
        //toDO! надо как-то оптимизировать, + сделать проверку на acy более универсальной,
        // вдруг появятся еще терминаторы, которые продаются только миксом
        const arrayOfPr = [];
        let priceMix = 0;
        let isAcy = 0;
        terms.forEach((term) => {
            if (allterms[term].price[0]?.priceForOne == false) {
                    isAcy += 1;
                }
            const pr = {
                terminator: term,
                price: allterms[term].price[0].rub,
                company: allterms[term].price[0].company,
                info: allterms[term].price[0].info
            };
            arrayOfPr.push(pr);
            if (isAcy>1 && allterms[term].price[0]?.priceForOne == false) {
                priceMix += 0
            } else {
                priceMix += pr.price;
            }
            
        })
        this.prices = arrayOfPr;
        this.sumPrice = priceMix;
    }

    priceCategory(cat) {
        let categories = cat;
        let ranges = [];
        for (let i = 0; i<(categories.length-1); i++) {
            let range = [];
                for (let ii=categories[i]; ii<categories[i+1]; ii++) {
                    range.push(ii);
                };
            ranges.push(range);
        };

        for (let i=0; i<ranges.length; i++) {
            if (ranges[i].some(a => a==this.sumPrice)){
                this.generalSort = {
                    category: i+1,
                    score: (i+1)*1000 + this.stats.sum
                }
            }
        }
    }
}



function checkMode (name) {
    let r=document.getElementsByName(name);
    let output = r[0].checked ? "suitable" : "all";
    return output
}

function clear(elementName) {
        while (elementName.firstChild) {
            elementName.firstChild.remove();
        }
    }

function run() {
    const terms = makeTermList();
    const preAllMixes = makeAllMixes(terms);

    const allMixes = [];
    for (let i=0; i<preAllMixes.length; i++) {
        allMixes.push(new Mix(preAllMixes[i]))
    }

    fullOut.setMixes = allMixes;
    fullOut.setModeAndRender = checkMode("r1");
    out.appendChild(fullOut);

}



function toShow (allmixes, show) {
    return allmixes.filter ((onemix) => 
        letters.some((letter) =>
            show.includes(onemix[letter].name)
        )
    )
}



const ButtonRun = document.getElementById("run");
ButtonRun.addEventListener("click", run);





</script>

</body>
</html>
